{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ESP32-Paxcounter","text":"<p>Wifi &amp; Bluetooth driven, LoRaWAN enabled, battery powered mini Paxcounter built on cheap ESP32 LoRa IoT boards</p> <p>Tutorial (in german language)</p> <p>Paxcounter dashboard with Pax.Express</p> <p> </p> <p>Documentation: https://cyberman54.github.io/ESP32-Paxcounter</p> <p>Source Code: https://github.com/cyberman54/ESP32-Paxcounter</p>"},{"location":"#use-case","title":"Use case","text":"<p>Paxcounter is an ESP32 MCU based device for metering passenger flows in realtime. It counts how many mobile devices are around. This gives an estimation how many people are around. Paxcounter detects Wifi and Bluetooth signals in the air, focusing on mobile devices by evaluating their MAC adresses.</p> <p>Info</p> <p>Intention of this project is to do this without intrusion in privacy: You don't need to track people owned devices, if you just want to count them. Therefore, Paxcounter does not persistenly store MAC adresses and *does no kind of fingerprinting the scanned devices.</p> <p>Data can either be be stored on a local SD-card, transferred to cloud using LoRaWAN network (e.g. TheThingsNetwork or Helium) or MQTT over TCP/IP, or transmitted to a local host using serial (SPI) interface.</p> <p>You can build this project battery powered using ESP32 deep sleep mode and reach long uptimes with a single 18650 Li-Ion cell.</p>"},{"location":"#impressions","title":"Impressions","text":""},{"location":"display-led/","title":"Display","text":"<p>If you're using a device with OLED display, or if you add such one to the I2C bus, the device shows live data on the display. You can flip display pages showing</p> <ul> <li>recent count of pax</li> <li>histogram</li> <li>GPS data</li> <li>BME sensor data</li> <li>time of day</li> <li>blank page</li> </ul> <p>by pressing the button of the device.</p>"},{"location":"display-led/#notes-on-powering-oled-display","title":"Notes on powering OLED display","text":"<p>Different OLED display pinouts:</p> <p>The TTGO T-beam boards do have solder pads for a pinheader which seems to be just right for a commonly used OLED display like the SSD1306.</p> <p>The most relevant pin pads are from left to right:</p> <ul> <li>GND</li> <li>3V3</li> <li>GND</li> <li>22 (SCL)</li> <li>21 (SDA)</li> <li>3.3V (label oddly differs from the other 3V3 labelled pin)</li> </ul> <p>However there are 2 versions of the SSD1306 OLED display available:</p> <ul> <li>Most common available: GND/Vdd/SCL/SDA</li> <li>Hard to find: Vdd/GND/SCL/SDA</li> </ul> <p>As can be seen, GND and Vdd are swapped and thus the most commonly available display version cannot be used without some tweaking.</p> <p>In order to make the most commonly available version fit, you can strip of the plastics from the power pins and carefully bend both GND and Vdd pins in a Z-shape so they will fit in the adjacent pin hole.</p> <p></p> <p>This way the display is still positioned correctly to fit in the many available 3D printable enclosure designs out there.</p> <p>Hardware mod for power-on issues:</p> <p>Some boards like the TTGO T-beam v1.0 and newer do have a power management chip.</p> <ul> <li>T-Beam v1.0 and v1.1 use AXP192</li> <li>T-Beam v1.2 and T-Supreme use AXP2101</li> </ul> <p>At least the ones using the AXP192 power management chip do have a annoying oversight in the board design.</p> <p>When powering on the board, the AXP192 is set to output 1.8V to both pads in the aforementioned pin header labelled \"3V3\" and \"3.3V\". If a display like the SSD1306 is soldered to use this as a power source, both I2C pins will be pulled down to about 1.8V + 0.3V = 2.1V by the protection diodes in the display controller. This may be too low to work properly for all other I2C connected devices.</p> <p>So the ESP32 may not be able to scan the I2C bus for any available I2C device and also not able to setup the AXP192 chip to output a higher voltage on the DCDC1 pin which powers the OLED display.</p> <p>This catch-22 situation can be resolved by adding a simple diode from GPIO-0 to the \"3.3V\" pad. (the 'line' on the diode towards the \"3.3V\" pad)</p> <p></p> <p>In this test setup, a basic 1N4001 is used, which has a voltage drop of about 0.5V. Another option is to use a germanium diode like the 1N4148, which does have a voltage drop of 0.3V.</p> <p>GPIO-0 is pulled up to the 3V3 net of the ESP32. This is required for the ESP32 to boot the flashed sketch and not enter flash mode when powered on.</p> <p>So as soon as the ESP32 is powered, the Vdd of the OLED display will be pulled up to 3.3V - 0.5V = 2.8V. This is enough for the I2C pins of the display to not being pulled down and thus the ESP32 can communicate with the AXP192 power management chip.</p> <p>N.B. Make sure the leads of the diode cannot short any of the other pins.</p>"},{"location":"display-led/#led-blink-pattern","title":"LED blink pattern","text":"<p>Mono color LED:</p> <ul> <li>Single Flash (50ms): seen a new Wifi or BLE device</li> <li>Quick blink (20ms on each 1/5 second): joining LoRaWAN network in progress or pending</li> <li>Small blink (10ms on each 1/2 second): LoRaWAN data transmit in progress or pending</li> <li>Long blink (200ms on each 2 seconds): LoRaWAN stack error</li> </ul> <p>RGB LED:</p> <ul> <li>Green: seen a new Wifi device</li> <li>Magenta: seen a new BLE device</li> <li>Yellow: joining LoRaWAN network in progress or pending</li> <li>Pink: LORAWAN MAC transmit in progress</li> <li>Blue: LoRaWAN data transmit in progress or pending</li> <li>Red: LoRaWAN stack errors</li> </ul>"},{"location":"getting-started/","title":"Preparing","text":""},{"location":"getting-started/#install-platformio","title":"Install Platformio","text":"<p>Install PlatformIO IDE for embedded development to build this project. Platformio integrates with your favorite IDE, choose e.g. Visual Studio Code, Atom, Eclipse etc.</p> <p>Compile time configuration is spread across several files. Before compiling the code, edit or create the following files:</p>"},{"location":"getting-started/#platformioini","title":"platformio.ini","text":"<p>Edit <code>platformio_orig.ini</code> (for ESP32 CPU based boards) or <code>platformio_orig_s3.ini</code> (for ESP32-S3 CPU based boards) and select desired board in section board. To add a new board, create an appropriate hardware abstraction layer file in hal subdirectory, and add a pointer to this file in section board. Copy or rename to <code>platformio.ini</code> in the root directory of the project. Now start Platformio.</p>"},{"location":"getting-started/#selecting-a-board","title":"Selecting a board","text":"Uncomment your board<pre><code>;\n[board]\n;halfile = generic.h\n;halfile = ebox.h\n;halfile = eboxtube.h\n;halfile = ecopower.h\n;halfile = heltec.h\n;halfile = heltecv2.h\n;halfile = heltecv21.h\n;halfile = ttgov1.h\n;halfile = ttgov2.h\n;halfile = ttgov21old.h\nhalfile = ttgov21new.h\n;halfile = ttgofox.h\n;halfile = ttgobeam.h\n;halfile = ttgobeam10.h\n;halfile = ttgobeam12.h\n;halfile = ttgotdisplay.h\n;halfile = ttgotwristband.h\n;halfile = fipy.h\n;halfile = lopy.h\n;halfile = lopy4.h\n;halfile = lolin32litelora.h\n;halfile = lolin32lora.h\n;halfile = lolin32lite.h\n;halfile = wemos32oled.h\n;halfile = wemos32matrix.h\n;halfile = octopus32.h\n;halfile = tinypico.h\n;halfile = tinypicomatrix.h\n;halfile = m5core.h\n</code></pre> CopyRename <pre><code>cp platformio_orig.ini platformio.ini\n</code></pre> <pre><code>mv platformio_orig.ini platformio.ini\n</code></pre> platformio_orig_s3.ini CopyRename <pre><code>cp platformio_orig_s3.ini platformio.ini\n</code></pre> <pre><code>mv platformio_orig_s3.ini platformio.ini\n</code></pre> <p>Info</p> <p>Platformio is looking for <code>platformio.ini</code> in the root directory and won't start if it does not find this file!</p>"},{"location":"getting-started/#paxcounterconf","title":"paxcounter.conf","text":"<p>Edit <code>shared/paxcounter_orig.conf</code> and tailor settings in this file according to your needs and use case. Please take care of the duty cycle regulations of the LoRaWAN network you're going to use. Copy or rename to <code>shared/paxcounter.conf</code>.</p> CopyRename <pre><code>cp shared/paxcounter_orig.conf shared/paxcounter.conf\n</code></pre> <pre><code>mv shared/paxcounter_orig.conf shared/paxcounter.conf\n</code></pre> <p>If your device has a real time clock it can be updated by either LoRaWAN network or GPS time, according to settings TIME_SYNC_INTERVAL and TIME_SYNC_LORAWAN in <code>paxcounter.conf</code>.</p> paxcounter.conf<pre><code>#define RESPONSE_TIMEOUT_MS             60000   // firmware binary server connection timeout [milliseconds]\n</code></pre>"},{"location":"getting-started/#sharedlmic_configh","title":"shared/lmic_config.h","text":"<p>Edit <code>shared/lmic_config.h</code> and tailor settings in this file according to your country and device hardware. Please take care of national regulations when selecting the frequency band for LoRaWAN.</p> national regulations in shared/lmic_config.h<pre><code>//#define CFG_au915 1 // Australia\n//#define CFG_as923 1 // Asia\n//#define CFG_kr920 1 // Korea\n\n// LMIC LORAWAN STACK SETTINGS\n// --&gt; adapt to your device only if necessary\n\n// use interrupts only if LORA_IRQ and LORA_DIO are connected to interrupt\n// capable and separate GPIO pins on your board, if not don't enable\n// note: this feature can't be used on ESP32 unless PR #556 of MCCI LMIC was merged\n</code></pre>"},{"location":"getting-started/#sharedloraconfh","title":"shared/loraconf.h","text":"<p>Create file <code>shared/loraconf.h</code> using the template shared/loraconf_sample.h and adjust settings to use your personal values. To join the network and activate your paxcounter, you must configure either OTAA or ABP join method. You should use OTAA, whenever possible. To understand the differences of the two methods, this article may be useful.</p> CopyRename <pre><code>cp shared/loraconf_sample.h shared/loraconf.h\n</code></pre> <pre><code>mv shared/loraconf_sample.h shared/loraconf.h\n</code></pre> <p>To configure OTAA, leave <code>#define LORA_ABP</code> deactivated (commented). To use ABP, activate (uncomment) <code>#define LORA_ABP</code> in the file <code>shared/loraconf.h</code>. The file <code>shared/loraconf_sample.h</code> contains more information about the values to provide.</p> Activate OTAA (Default), Deactivate ABPDeactivate OTAA, Activate ABP shared/loraconf.h<pre><code>//#define LORA_ABP\n</code></pre> shared/loraconf.h<pre><code>#define LORA_ABP\n</code></pre>"},{"location":"getting-started/#sharedotaconf","title":"shared/ota.conf","text":"<p>Create file <code>shared/ota.conf</code> using the template shared/ota_sample.conf and enter your WIFI network &amp; key. These settings are used for downloading updates via WiFi, either from a remote https server, or locally via WebUI. If you want to use a remote server, you need a PAX.express repository. Enter your PAX.express credentials in ota.conf. If you don't need wireless firmware updates just rename ota.sample.conf to ota.conf.</p> CopyRename <pre><code>cp shared/ota_sample.conf shared/ota.conf\n</code></pre> <pre><code>mv shared/ota_sample.conf shared/ota.conf\n</code></pre>"},{"location":"getting-started/#building","title":"Building","text":"<p>Use PlatformIO with your preferred IDE for development and building this code. Make sure you have latest PlatformIO version.</p>"},{"location":"getting-started/#uploading","title":"Uploading","text":"<p>Warning</p> <ol> <li>After editing <code>paxcounter.conf</code>, use \"clean\" button before \"build\" in PlatformIO!</li> <li>Clear NVRAM of the board to delete previous stored runtime settings (<code>pio run -t erase</code>)</li> </ol> <ul> <li> <p>by cable, via USB/UART interface: To upload the code via cable to your ESP32 board this needs to be switched from run to bootloader mode. Boards with USB bridge like Heltec and TTGO usually have an onboard logic which allows soft switching by the upload tool. In PlatformIO this happenes automatically.<p> The LoPy/LoPy4/FiPy board needs to be set manually. See these instructions how to do it. Don't forget to press on board reset button after switching between run and bootloader mode.<p> The original Pycom firmware is not needed, so there is no need to update it before flashing Paxcounter. Just flash the compiled paxcounter binary (.elf file) on your LoPy/LoPy4/FiPy. If you later want to go back to the Pycom firmware, download the firmware from Pycom and flash it over.</p> <li> <p>over the air (OTA), download via WiFi: After the ESP32 board is initially flashed and has joined a LoRaWAN network, the firmware can update itself by OTA. This process is kicked off by sending a remote control command (see below) via LoRaWAN to the board. The board then tries to connect via WiFi to a cloud service (PAX.express), checks for update, and if available downloads the binary and reboots with it. If something goes wrong during this process, the board reboots back to the current version. Prerequisites for OTA are: 1. You own a PAX.express repository, 2. you pushed the update binary to your PAX.express repository, 3. internet access via encrypted (WPA2) WiFi is present at the board's site, 4. WiFi credentials were set in ota.conf and initially flashed to the board. Step 2 runs automated, just enter the credentials in ota.conf and set <code>upload_protocol = custom</code> in platformio.ini. Then press build and lean back watching platformio doing build and upload.</p> </li> <li> <p>over the air (OTA), upload via WiFi: If option BOOTMENU is defined in <code>paxcounter.conf</code>, the ESP32 board will try to connect to a known WiFi access point each time cold starting (after a power cycle or a reset), using the WiFi credentials given in <code>ota.conf</code>. Once connected to the WiFi it will fire up a simple webserver, providing a bootstrap menu waiting for a user interaction (pressing \"START\" button in menu). This process will time out after BOOTDELAY seconds, ensuring booting the device to runmode. Once a user interaction in bootstrap menu was detected, the timeout will be extended to BOOTTIMEOUT seconds. During this time a firmware upload can be performed manually by user, e.g. using a smartphone in tethering mode providing the firmware upload file.</p> </li>"},{"location":"hardware/","title":"Hardware","text":""},{"location":"hardware/#supported-esp32-based-boards","title":"Supported ESP32 based boards:","text":"<p>With LoRa radio data transfer:</p> <ul> <li>LILYGO\u00ae: Paxcounter LoRa V2.1*</li> <li>TTGO: T1, T2, T3, T-Beam (1.0/1.1/1.2), T-Fox, T-Supreme, T-Display, T-Dongle</li> <li>Heltec: LoRa-32 v1/v2/v3, Stick Lite V3</li> <li>Pycom: LoPy, LoPy4, FiPy</li> <li>Radioshuttle.de: ECO Power Board</li> <li>WeMos: LoLin32 + LoraNode32 shield, LoLin32lite + LoraNode32-Lite shield</li> <li>Adafruit ESP32 Feather + LoRa Wing + OLED Wing, #IoT Octopus32 (Octopus + ESP32 Feather)</li> <li>M5Stack: Basic Core IoT* + Lora Module RA-01H, Fire IoT*</li> </ul> <p>Without LoRa:</p> <ul> <li>LILYGO\u00ae: T-Dongle S3*</li> <li>Pyom: WiPy</li> <li>WeMos: LoLin32, LoLin32 Lite, WeMos D32, Wemos32 Oled</li> <li>Crowdsupply: TinyPICO</li> <li>TTGO: T-Display</li> <li>TTGO: T-Wristband</li> <li>Generic ESP32</li> </ul> <p>*) supports microSD/TF-card for local logging of paxcounter data. SD/TF-card must be FAT32 formatted.</p> <p>Depending on board hardware following features are supported:</p> <ul> <li>LoRaWAN communication, supporting various payload formats (see enclosed .js converters)</li> <li>MQTT communication via TCP/IP and Ethernet interface (note: payload transmitted over MQTT will be base64 encoded)</li> <li>SPI serial communication to a local host</li> <li>LED (shows power &amp; status)</li> <li>OLED Display (shows detailed status)</li> <li>RGB LED (shows colorized status)</li> <li>Button (short press: flip display page / long press: send alarm message)</li> <li>Battery voltage monitoring (analog read / AXP192 / AXP202 / AXP2101 / IP5306)</li> <li>GPS (Generic serial NMEA, or Quectel L76 I2C)</li> <li>Environmental sensors (Bosch BMP180/BME280/BME680/BMP280 I2C; SDS011 serial)</li> <li>Real Time Clock (Maxim DS3231 I2C)</li> <li>IF482 (serial) and DCF77 (gpio) time telegram generator</li> <li>Switch external power / battery</li> <li>LED Matrix display (similar to this 64x16 model, can be ordered on Aliexpress)</li> <li>SD-card (see section SD-card here) for logging pax data</li> </ul> <p>Target platform must be selected in <code>platformio.ini</code>. Hardware dependent settings (pinout etc.) are stored in board files in /shared/hal directory. If you want to use a ESP32 board which is not yet supported, use hal file generic.h and tailor pin mappings to your needs. Pull requests for new boards welcome.</p>"},{"location":"hardware/#3d-printed-cases","title":"3D printed cases","text":"<p>Some 3D printable cases can be found (and, if wanted so, ordered) on Thingiverse, see</p> <ul> <li>Heltec</li> <li>TTGOv2</li> <li>TTGOv2.1</li> <li>TTGO</li> <li>T-BEAM</li> <li>T-BEAM parts</li> </ul>"},{"location":"hardware/#power-consumption","title":"Power consumption","text":"<p>Power consumption was metered at around 450 - 1000mW, depending on board and user settings in <code>paxcounter.conf</code>.</p> <p>By default, bluetooth sniffing is not started. If you enable bluetooth be aware that this goes on expense of wifi sniffing results, because then wifi and bt stack must share the 2,4 GHz RF ressources of ESP32. If you need to sniff wifi and bt in parallel and need best possible results, use two boards - one for wifi only and one for bt only - and add counted results.</p> Deactivate BLE sniffing (Default)Activate BLE sniffing paxcounter.conf<pre><code>#define BLECOUNTER 0\n</code></pre> paxcounter.conf<pre><code>#define BLECOUNTER 1\n</code></pre>"},{"location":"integrations/","title":"Integration LoRaWAN","text":""},{"location":"integrations/#the-things-stack-community-edition-aka-the-things-stack-v3","title":"\"The Things Stack Community Edition\" aka \"The Things Stack V3\"","text":"<p>To use the ESP32-Paxcounter in The Things Stack Community Edition you need an account to reach the console. Go to:</p> <ul> <li>The Things Stack Community Edition Console</li> <li>choose your region and go to applications</li> <li>create an application by clicking \"+ Add application\" and give it a id, name, etc.</li> <li>create a device by clicking \"+ Add end device\"</li> <li>Select the end device:  choose the Brand \"Open Source Community Projects\" and the Model \"ESP32-Paxcounter\", leave Hardware Version to \"Unknown\" and select your Firmware Version and Profile (Region)</li> <li>Enter registration data: choose the frequency plan (for EU choose the recommended), set the AppEUI (Fill with zeros), set the DeviceEUI (generate), set the AppKey (generate), choose a device ID and hit \"Register end device\"</li> <li>got to Applications -&gt; \"your App ID\" -&gt; Payload formatters -&gt; Uplink, choose \"Repository\" and hit \"Save changes\"</li> </ul> <p>The \"Repository\" payload decoder uses the packed format, explained below. If you want to use MyDevices from Cayenne you should use the Cayenne payload decoder instead.</p>"},{"location":"integrations/#ttn-mapper","title":"TTN Mapper","text":"<p>If you want your devices to be feeding the TTN Mapper, just follow this manual: https://docs.ttnmapper.org/integration/tts-integration-v3.html - different than indicated in the manual you can leave the payload decoder to \"Repository\" for the ESP32-Paxcounter and you are fine.</p>"},{"location":"integrations/#chirpstack","title":"ChirpStack","text":"<p>Todo</p>"},{"location":"legalnote/","title":"Legal note","text":"<p>Depending on your country's laws it may be illegal to sniff wireless networks for MAC addresses. Please check and respect your country's laws before using this code!</p> <ul> <li> <p>(e.g. US citizens may want to check Section 18 U.S. Code \u00a7 2511 and discussion on this)</p> </li> <li> <p>(e.g. UK citizens may want to check Data Protection Act 1998 and GDPR 2018)</p> </li> <li> <p>(e.g. Citizens in the the Netherlands and EU may want to read this article and this article and this decision)</p> </li> <li> <p>(e.g. Citizens in Germany may want to read this article of Wissenschaftliche Dienste des Deutschen Bundestages)</p> </li> </ul> <p>Info</p> <p>If you use this software you do this at your own risk. That means that you alone - not the authors of this software - are responsible for the legal compliance of an application using this or build from this software and/or usage of a device created using this software. You should take special care and get prior legal advice if you plan metering passengers in public areas and/or publish data drawn from doing so.</p>"},{"location":"legalnote/#privacy-disclosure","title":"Privacy disclosure","text":"<p>Paxcounter generates identifiers for sniffed Wifi or Bluetooth MAC adresses and and collects them temporary in the device's RAM for a configurable scan cycle time (default 60 seconds). After each scan cycle the collected identifiers are cleared. Identifiers are generated by using the last 2 bytes of universal MAC adresses. Personal MAC adresses remain untouched and are not evaluated. Identifiers and MAC adresses are never transferred to the LoRaWAN network. No persistent storing of MAC adresses, identifiers or timestamps and no other kind of analytics than counting are implemented in this code. Wireless networks are not touched by this code, but MAC adresses from wireless devices as well within as not within wireless networks, regardless if encrypted or unencrypted, are sniffed and processed by this code.</p>"},{"location":"license-credits/","title":"License","text":"<p>Copyright  2018-2022 Oliver Brandmueller ob@sysadm.in</p> <p>Copyright  2018-2022 Klaus Wilting verkehrsrot@arcor.de</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\");    you may not use this file except in compliance with the License.    You may obtain a copy of the License at</p> <p>http://www.apache.org/licenses/LICENSE-2.0</p> <p>Unless required by applicable law or agreed to in writing, software    distributed under the License is distributed on an \"AS IS\" BASIS,    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.    See the License for the specific language governing permissions and    limitations under the License.</p> <p>Info</p> <p>Parts of the source files in this repository are made available under different licenses, see file LICENSE.txt in this repository. Refer to each individual source file for more details.</p>"},{"location":"license-credits/#credits","title":"Credits","text":"<p>Thanks to</p> <ul> <li>Oliver Brandm\u00fcller for idea and initial setup of this project</li> <li>Charles Hallard for major code contributions to this project</li> <li>robbi5 for the payload converter</li> <li>Caspar Armster for the The Things Stack V3 payload converter</li> <li>terrillmoore for maintaining the LMIC for arduino LoRaWAN stack</li> <li>sbamueller for writing the tutorial in Make Magazine</li> <li>Stefan for paxcounter opensensebox integration</li> <li>August Quint for adding SD card data logger and SDS011 support</li> <li>t-huyeng for adding a CI workflow and rework documentation</li> <li>TD-er for bugfixings and T-Beam documentation</li> </ul>"},{"location":"payloadformat/","title":"Payload format","text":"<p>You can select different payload formats in <code>paxcounter.conf</code>:</p> <ul> <li> <p>Plain uses big endian format and generates json fields, e.g. useful for TTN console</p> </li> <li> <p>Packed uses little endian format and generates json fields (exception: floats are big endian encoded)</p> </li> <li> <p>CayenneLPP generates MyDevices Cayenne readable fields</p> </li> </ul> shared/paxcounter_orig.conf<pre><code>#define SLEEPCYCLE                      0       // sleep time after a send cycle [seconds/10], 0 .. 65535; 0 means no sleep [default = 0]\n</code></pre> <p>Decrepated information from the things network v2</p> <p>If you're using TheThingsNetwork (TTN) you may want to use a payload converter. Go to TTN Console - Application - Payload Formats and paste the code example below in tabs Decoder and Converter. This way your MQTT application can parse the fields <code>pax</code>, <code>ble</code> and <code>wifi</code>.</p> <p>To add your device to myDevices Cayenne platform select \"Cayenne-LPP\" from Lora device list and use the CayenneLPP payload encoder.</p> <p>To track a paxcounter device with on board GPS and at the same time contribute to TTN coverage mapping, you simply activate the TTNmapper integration in TTN Console. Both formats plain and packed generate the fields <code>latitude</code>, <code>longitude</code> and <code>hdop</code> required by ttnmapper. Important: set TTN mapper port filter to '4' (paxcounter GPS Port).</p> <p>Hereafter described is the default plain format, which uses MSB bit numbering. Under /TTN in this repository you find some ready-to-go decoders which you may copy to your TTN console:</p> <p>plain_decoder.js | plain_converter.js | packed_decoder.js | packed_converter.js</p> <p>Port #1: Paxcount data</p> <pre><code>byte 1-2:       Number of unique devices, seen on Wifi [00 00 if Wifi scan disabled]\nbyte 3-4:       Number of unique devices, seen on Bluetooth [ommited if BT scan disabled]\n</code></pre> <p>Port #2: Device status query result</p> <pre><code>byte 1-2:       Battery or USB Voltage [mV], 0 if no battery probe\nbyte 3-10:      Uptime [seconds]\nbyte 11:        CPU temperature [\u00b0C]\nbytes 12-15:    Free RAM [bytes]\nbyte 16:        Last CPU core 0 reset reason\nbytes 17-20:    Number of restarts since last power cycle\n</code></pre> <p>Port #3: Device configuration query result</p> <pre><code>byte 1:         Lora DR (0..15, see rcommand 0x05) [default 5]\nbyte 2:         Lora TXpower (2..15) [default 15]\nbyte 3:         Lora ADR (1=on, 0=off) [default 1]\nbyte 4:         Screensaver status (1=on, 0=off) [default 0]\nbyte 5:         Display status (1=on, 0=off) [default 0]\nbyte 6:         Counter mode (0=cyclic unconfirmed, 1=cumulative, 2=cyclic confirmed) [default 0]\nbytes 7-8:      RSSI limiter threshold value (negative, MSB) [default 0]\nbyte 9:         Scan and send cycle in seconds/2 (0..255) [default 120]\nbyte 10:        Wifi channel hopping interval in seconds/100 (0..255), 0 means no hopping [default 50]\nbyte 11:        Bluetooth channel switch interval in seconds/100 (0..255) [default 10]\nbyte 12:        Bluetooth scanner status (1=on, 0=0ff) [default 1]\nbyte 13:        Wifi antenna switch (0=internal, 1=external) [default 0]\nbytes 14-15:    Sleep cycle in seconds/10 (MSB) [default 0]\nbyte 16:        Payloadmask (Bitmask, 0..255, see rcommand 0x14)\nbyte 17:        0 (reserved)\nbytes 18-28:    Software version (ASCII format, terminating with zero)\n</code></pre> <p>Port #4: GPS data (only if device has fature GPS, and GPS data is enabled and GPS has a fix)</p> <pre><code>bytes 1-4:      Latitude\nbytes 5-8:      Longitude\nbyte 9:         Number of satellites\nbytes 10-11:    HDOP\nbytes 12-13:    Altitude [meter]\n</code></pre> <p>Port #5: Button pressed alarm</p> <pre><code>byte 1:         static value 0x01\n</code></pre> <p>Port #6: (unused)</p> <p>Port #7: Environmental sensor data (only if device has feature BME)</p> <pre><code>bytes 1-2:  Temperature [\u00b0C]\nbytes 3-4:  Pressure [hPa]\nbytes 5-6:  Humidity [%]\nbytes 7-8:  Indoor air quality index (0..500), see below\n\nIndoor air quality classification:\n0-50        good\n51-100      average\n101-150     little bad\n151-200     bad\n201-300     worse\n301-500     very bad\n</code></pre> <p>Port #8: Battery voltage data (only if device has feature BATT)</p> <pre><code>bytes 1-2:  Battery or USB Voltage [mV], 0 if no battery probe\n</code></pre> <p>Port #9: Time/Date</p> <pre><code>bytes 1-4:  board's local time/date in UNIX epoch (number of seconds that have elapsed since January 1, 1970 (midnight UTC/GMT), not counting leap seconds)\n</code></pre> <p>Ports #10, #11, #12: User sensor data</p> <pre><code>Format is specified by user in function `sensor_read(uint8_t sensor)`, see `src/sensor.cpp`.\n</code></pre>"},{"location":"releases/","title":"Releases","text":"<p>See all releases at https://github.com/cyberman54/ESP32-Paxcounter/releases.</p>"},{"location":"remotecontrol/","title":"Remote control","text":"<p>The device listenes for remote control commands on LoRaWAN Port 2. Multiple commands per downlink are possible by concatenating them, but must not exceed a maximum of 10 bytes per downlink.</p> <p>Info</p> <p>Settings can be stored in NVRAM to make them persistant (reloaded during device startup / restart). To store settings, use command <code>0x21</code>.</p> <p>Send for example <code>83</code> <code>86</code> as Downlink on Port 2 to get battery status and time/date from the device.</p> <p></p>"},{"location":"remotecontrol/#0x01-set-scan-rssi-limit","title":"0x01 set scan RSSI limit","text":"<pre><code>1 ... 255 used for wifi and bluetooth scan radius (greater values increase scan radius, values 50...110 make sense)\n0 = RSSI limiter disabled [default]\n</code></pre>"},{"location":"remotecontrol/#0x02-set-counter-mode","title":"0x02 set counter mode","text":"<pre><code>0 = cyclic unconfirmed, mac counter reset after each wifi scan cycle, data is sent only once [default]\n1 = cumulative counter, mac counter is never reset\n2 = cyclic confirmed, like 0 but data is resent until confirmation by network received\n</code></pre>"},{"location":"remotecontrol/#0x03-set-gps-data-onoff","title":"0x03 set GPS data on/off","text":"<pre><code>0 = GPS data off\n1 = GPS data on, sends GPS data on port 4 (default, use port 1 for mobile pax counter), if GPS is present and has a fix\n</code></pre>"},{"location":"remotecontrol/#0x04-set-display-onoff","title":"0x04 set display on/off","text":"<pre><code>0 = display off\n1 = display on [default]\n</code></pre>"},{"location":"remotecontrol/#0x05-set-lora-datarate","title":"0x05 set LoRa datarate","text":"<pre><code>0 ... 15 see LoRaWAN regional parameters for details [default: 5]\n\nExample for EU868:\n\nDataRate    Configuration           Bit/s\n0           LoRa: SF12 / 125 kHz    250\n1           LoRa: SF11 / 125 kHz    440\n2           LoRa: SF10 / 125 kHz    980\n3           LoRa: SF9 / 125 kHz     1760\n4           LoRa: SF8 / 125 kHz     3125\n5           LoRa: SF7 / 125 kHz     5470\n6*          LoRa: SF7 / 250 kHz     11000\n7*          FSK: 50 kbps            50000\n8 .. 14     reserved for future use (RFU)\n15          ignored (device keeps current setting)\n\n*) not supported by TheThingsNetwork\n</code></pre>"},{"location":"remotecontrol/#0x06-set-lora-txpower","title":"0x06 set LoRa TXpower","text":"<pre><code>0 ... 255 desired TX power in dBm [default: 14]\n</code></pre>"},{"location":"remotecontrol/#0x07-set-lora-adaptive-data-rate-mode","title":"0x07 set LoRa Adaptive Data Rate mode","text":"<pre><code>0 = ADR off\n1 = ADR on [default]\n\nIf ADR is set to off, SF value is shown inverted on display.\n</code></pre>"},{"location":"remotecontrol/#0x08-do-nothing","title":"0x08 do nothing","text":"<pre><code>useful to clear pending commands from LoRaWAN server quere, or to check RSSI on device\n</code></pre>"},{"location":"remotecontrol/#0x09-reset-functions-send-this-command-unconfirmed-only-to-avoid-boot-loops","title":"0x09 reset functions (send this command UNconfirmed only to avoid boot loops!)","text":"<pre><code>0 = restart device (coldstart)\n1 = (reserved, currently does nothing)\n2 = reset device to factory settings and restart device\n3 = flush send queues\n4 = restart device (warmstart)\n8 = reboot device to maintenance mode (local web server)\n9 = reboot device to OTA update via Wifi mode\n</code></pre>"},{"location":"remotecontrol/#0x0a-set-payload-send-cycle","title":"0x0A set payload send cycle","text":"<pre><code>5 ... 255 payload send cycle in seconds/2\ne.g. 120 -&gt; payload is transmitted each 240 seconds [default]\n</code></pre>"},{"location":"remotecontrol/#0x0b-set-wifi-channel-hopping-interval-timer","title":"0x0B set Wifi channel hopping interval timer","text":"<pre><code>0 ... 255 duration for scanning a wifi channel in seconds/100\ne.g. 50 -&gt; each channel is scanned for 500 milliseconds [default]\n0 means no hopping, scanning on fixed single channel WIFI_CHANNEL_1\n</code></pre>"},{"location":"remotecontrol/#0x0c-set-bluetooth-channel-switch-interval-timer","title":"0x0C set Bluetooth channel switch interval timer","text":"<pre><code>0 ... 255 duration for scanning a bluetooth advertising channel in seconds/100\ne.g. 8 -&gt; each channel is scanned for 80 milliseconds [default]\n</code></pre>"},{"location":"remotecontrol/#0x0d-set-wakeup-sync-window","title":"0x0D set wakeup sync window","text":"<pre><code>bytes 1..2 = wakeup sync window size in seconds (MSB), 0..255 (0 = no wakuep sync)\ne.g. {0x02, 0x58} -&gt; device adjusts it's wakeup time when it is +/- 5 minutes from top-of-hour [default = 0]\n</code></pre>"},{"location":"remotecontrol/#0x0e-set-bluetooth-scanner","title":"0x0E set Bluetooth scanner","text":"<pre><code>0 = disabled\n1 = enabled [default]\n</code></pre>"},{"location":"remotecontrol/#0x0f-set-wifi-antenna-switch-works-on-lopylopy4fipy-only","title":"0x0F set WIFI antenna switch (works on LoPy/LoPy4/FiPy only)","text":"<pre><code>0 = internal antenna [default]\n1 = external antenna\n</code></pre>"},{"location":"remotecontrol/#0x10-set-rgb-led-luminosity-works-on-lopylopy4fipy-and-loranode32-shield-only","title":"0x10 set RGB led luminosity (works on LoPy/LoPy4/FiPy and LoRaNode32 shield only)","text":"<pre><code>0 ... 100 percentage of luminosity (100% = full light)\ne.g. 50 -&gt; 50% of luminosity [default]\n</code></pre>"},{"location":"remotecontrol/#0x11-set-wifi-scanner-channel-map-bitmask","title":"0x11 set Wifi scanner channel map bitmask","text":"<pre><code>bytes 1..2 = wifi channel map bitmask (MSB), 0..8191\ne.g. 0b1010000001001 sets channels 1, 4, 11, 13\n</code></pre>"},{"location":"remotecontrol/#0x13-set-user-sensor-mode","title":"0x13 set user sensor mode","text":"<pre><code>byte 1 = user sensor number (1..3)\nbyte 2 = sensor mode (0 = disabled / 1 = enabled [default])\n</code></pre>"},{"location":"remotecontrol/#0x14-set-payload-mask","title":"0x14 set payload mask","text":"<pre><code>byte 1 = sensor data payload mask (0..255, meaning of bits see below)\n    0x01 = COUNT_DATA\n    0x02 = RESERVED_DATA\n    0x04 = MEMS_DATA\n    0x08 = GPS_DATA\n    0x10 = SENSOR_1_DATA\n    0x20 = SENSOR_2_DATA\n    0x40 = SENSOR_3_DATA\n    0x80 = BATT_DATA\nbytes can be combined eg COUNT_DATA + SENSOR_1_DATA + BATT_DATA: `0x01 | 0x10 | 0x80 = 0x91`\n</code></pre>"},{"location":"remotecontrol/#0x15-set-bme-data-onoff","title":"0x15 set BME data on/off","text":"<pre><code>0 = BME data off\n1 = BME data on, sends BME data on port 7 [default]\n</code></pre>"},{"location":"remotecontrol/#0x16-set-battery-data-onoff","title":"0x16 set battery data on/off","text":"<pre><code>0 = battery data off [default]\n1 = battery data on, sends voltage on port 8\n</code></pre>"},{"location":"remotecontrol/#0x17-set-wifi-scanner","title":"0x17 set Wifi scanner","text":"<pre><code>0 = disabled\n1 = enabled [default]\n</code></pre>"},{"location":"remotecontrol/#0x18-reserved","title":"0x18 reserved","text":"<pre><code>unused, does nothing\n</code></pre>"},{"location":"remotecontrol/#0x19-set-sleep-cycle","title":"0x19 set sleep cycle","text":"<pre><code>bytes 1..2 = device sleep cycle in seconds/10 (MSB), 0..65535 (0 = no sleep)\ne.g. {0x04, 0xB0} -&gt; device sleeps 200 minutes after each send cycle [default = 0]\n</code></pre>"},{"location":"remotecontrol/#0x20-load-device-configuration","title":"0x20 load device configuration","text":"<pre><code>Current device runtime configuration will be loaded from NVRAM, replacing current settings immediately (use with care!)\n</code></pre>"},{"location":"remotecontrol/#0x21-store-device-configuration","title":"0x21 store device configuration","text":"<pre><code>Current device runtime configuration is stored in NVRAM, will be reloaded after restart\n</code></pre>"},{"location":"remotecontrol/#0x80-get-device-configuration","title":"0x80 get device configuration","text":"<pre><code>Device answers with it's current configuration on Port 3.\n</code></pre>"},{"location":"remotecontrol/#0x81-get-device-status","title":"0x81 get device status","text":"<pre><code>Device answers with it's current status on Port 2.\n</code></pre>"},{"location":"remotecontrol/#0x83-get-battery-status","title":"0x83 get battery status","text":"<pre><code>Device answers with battery voltage on Port 8.\n</code></pre>"},{"location":"remotecontrol/#0x84-get-device-gps-status","title":"0x84 get device GPS status","text":"<pre><code>Device answers with it's current status on Port 4.\n</code></pre>"},{"location":"remotecontrol/#0x85-get-bme-sensor-data","title":"0x85 get BME sensor data","text":"<pre><code>Device answers with BME sensor data set on Port 7.\n</code></pre>"},{"location":"remotecontrol/#0x86-get-timedate","title":"0x86 get time/date","text":"<pre><code>Device answers with it's current time on Port 2:\n\nbytes 1..4 = time/date in UTC epoch seconds (LSB)\nbyte 5 = time source &amp; status, see below\n\n    bits 0..3 time source\n        0x00 = GPS\n        0x01 = RTC\n        0x02 = LORA\n        0x03 = unsynched\n        0x04 = set (source unknown)\n\n    bits 4..7 esp32 sntp time status\n        0x00 = SNTP_SYNC_STATUS_RESET\n        0x01 = SNTP_SYNC_STATUS_COMPLETED\n        0x02 = SNTP_SYNC_STATUS_IN_PROGRESS\n</code></pre>"},{"location":"remotecontrol/#0x87-sync-timedate","title":"0x87 sync time/date","text":"<pre><code>Device synchronizes it's time/date by calling the preconfigured time source.\n</code></pre>"},{"location":"remotecontrol/#0x88-set-timedate","title":"0x88 set time/date","text":"<pre><code>bytes 1..4 = time/date to set in UTC epoch seconds (MSB, e.g. https://www.epochconverter.com/hex)\n</code></pre>"},{"location":"configuration/","title":"Configuration","text":""},{"location":"configuration/#sensors-and-peripherals","title":"Sensors and Peripherals","text":"<p>You can add up to 3 user defined sensors. Insert your sensor's payload scheme in <code>sensor.cpp</code>. More examples and a detailed description can be found in the sensor documentation.</p>"},{"location":"configuration/#supported-peripherals","title":"Supported Peripherals","text":"<ul> <li>Bosch BMP180 / BME280 / BMP280 / BMP680</li> <li>SDS011</li> <li>RTC DS3231</li> <li>generic serial NMEA GPS</li> <li>I2C Lopy GPS</li> </ul> <p>For these peripherals no additional code is needed. To activate configure them in the board's hal file before building the code.</p> <p>See <code>generic.h</code> for all options and for proper configuration of BME280/BME680.</p> BME/ BMP ConfigurationSDS011 ConfigurationCustom Sensors ConfigurationComplete <code>generic.h</code> shared/hal/generic.h<pre><code>// BME680 sensor on I2C bus\n//#define HAS_BME 1 // Enable BME sensors in general\n//#define HAS_BME680 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL\n//#define BME680_ADDR BME68X_I2C_ADDR_LOW // connect SDIO of BME680 to GND\n\n// BME280 sensor on I2C bus\n//#define HAS_BME 1 // Enable BME sensors in general\n//#define HAS_BME280 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL\n//#define BME280_ADDR 0x76 // change to 0x77 depending on your wiring\n\n// BMP180 sensor on I2C bus\n//#define HAS_BME 1 // Enable BME sensors in general\n//#define HAS_BMP180\n//#define BMP180_ADDR 0x77\n\n// BMP280 sensor on I2C bus\n//#define HAS_BME 1 // Enable BME sensors in general\n//#define HAS_BMP280\n//#define BMP280_ADDR 0x76\n</code></pre> shared/hal/generic.h<pre><code>// SDS011 dust sensor settings\n//#define HAS_SDS011 1 // use SDS011\n// used pins on the ESP-side:\n//#define SDS_TX 19     // connect to RX on the SDS011\n//#define SDS_RX 23     // connect to TX on the SDS011\n</code></pre> shared/hal/generic.h<pre><code>// up to three user defined sensors (if connected)\n//#define HAS_SENSOR_1 1 // comment out if device has user defined sensor #1\n//#define HAS_SENSOR_2 1 // comment out if device has user defined sensor #2\n//#define HAS_SENSOR_3 1 // comment out if device has user defined sensor #3\n</code></pre> shared/hal/generic.h<pre><code>// clang-format off\n// upload_speed 115200\n// board esp32dev\n\n#ifndef _GENERIC_H\n#define _GENERIC_H\n\n#include &lt;stdint.h&gt;\n\n// Hardware related definitions for generic ESP32 boards\n// generic.h is kitchensink with all available options\n\n#define HAS_LORA 1 // comment out if device shall not send data via LoRa or has no LoRa\n//#define HAS_SPI 1  // comment out if device shall not send data via SPI\n// pin definitions for SPI slave interface\n//#define SPI_MOSI GPIO_NUM_23\n//#define SPI_MISO GPIO_NUM_19\n//#define SPI_SCLK GPIO_NUM_18\n//#define SPI_CS   GPIO_NUM_5\n\n// enable only if you want to store a local paxcount table on the device\n#define HAS_SDCARD  1      // this board has an SD-card-reader/writer\n// Pins for SD-card\n#define SDCARD_CS    (13)\n#define SDCARD_MOSI  (15)\n#define SDCARD_MISO  (2)\n#define SDCARD_SCLK  (14)\n\n// enable only if device has these sensors, otherwise comment these lines\n// tutorial to connect BME sensor see here:\n// https://sbamueller.wordpress.com/2019/02/26/paxcounter-mit-umweltsensor/\n//\n// in platformio.ini append\n// lib_deps = &lt;...&gt; ${common.lib_deps_sensors}\n// for loading necessary libraries\n\n// BME680 sensor on I2C bus\n//#define HAS_BME 1 // Enable BME sensors in general\n//#define HAS_BME680 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL\n//#define BME680_ADDR BME68X_I2C_ADDR_LOW // connect SDIO of BME680 to GND\n\n// BME280 sensor on I2C bus\n//#define HAS_BME 1 // Enable BME sensors in general\n//#define HAS_BME280 GPIO_NUM_21, GPIO_NUM_22 // SDA, SCL\n//#define BME280_ADDR 0x76 // change to 0x77 depending on your wiring\n\n// BMP180 sensor on I2C bus\n//#define HAS_BME 1 // Enable BME sensors in general\n//#define HAS_BMP180\n//#define BMP180_ADDR 0x77\n\n// BMP280 sensor on I2C bus\n//#define HAS_BME 1 // Enable BME sensors in general\n//#define HAS_BMP280\n//#define BMP280_ADDR 0x76\n\n// SDS011 dust sensor settings\n//#define HAS_SDS011 1 // use SDS011\n// used pins on the ESP-side:\n//#define SDS_TX 19     // connect to RX on the SDS011\n//#define SDS_RX 23     // connect to TX on the SDS011\n\n// up to three user defined sensors (if connected)\n//#define HAS_SENSOR_1 1 // comment out if device has user defined sensor #1\n//#define HAS_SENSOR_2 1 // comment out if device has user defined sensor #2\n//#define HAS_SENSOR_3 1 // comment out if device has user defined sensor #3\n\n#define CFG_sx1276_radio 1 // select LoRa chip\n//#define CFG_sx1272_radio 1 // select LoRa chip\n//#define BOARD_HAS_PSRAM // use if board has external SPIRAM, note: this will reduce IRAM0 by 64KB for SPIRAM cache\n#define DISABLE_BROWNOUT 1 // comment out if you want to keep brownout feature\n\n//#define HAS_DISPLAY 1\n//#define MY_DISPLAY_FLIP  1 // use if display is rotated\n#define BAT_MEASURE_ADC ADC1_GPIO35_CHANNEL // battery probe GPIO pin -&gt; ADC1_CHANNEL_7\n#define BAT_VOLTAGE_DIVIDER 2 // voltage divider 100k/100k on board\n\n#define HAS_LED (21) // on board  LED\n#define HAS_BUTTON (39) // on board button\n//#define RGB_LED_COUNT 1 // we have 1 LED\n//#define HAS_RGB_LED FastLED.addLeds&lt;WS2812, GPIO_NUM_0, GRB&gt;(leds, RGB_LED_COUNT);\n\n// GPS settings\n//#define HAS_GPS 1 // use on board GPS\n//#define GPS_SERIAL 9600, SERIAL_8N1, GPIO_NUM_12, GPIO_NUM_15 // UBlox NEO 6M RX, TX\n//#define GPS_INT GPIO_NUM_13 // 30ns accurary timepulse, to be external wired on pcb: NEO 6M Pin#3 -&gt; GPIO13\n\n// Pins for I2C interface of OLED Display\n//#define MY_DISPLAY_SDA (4)\n//#define MY_DISPLAY_SCL (15)\n//#define MY_DISPLAY_RST (16)\n\n// Settings for on board DS3231 RTC chip\n//#define HAS_RTC MY_DISPLAY_SDA, MY_DISPLAY_SCL // SDA, SCL\n//#define RTC_INT GPIO_NUM_34 // timepulse with accuracy +/- 2*e-6 [microseconds] = 0,1728sec / day\n\n// Settings for IF482 interface\n//#define HAS_IF482 9600, SERIAL_7E1, GPIO_NUM_12, GPIO_NUM_14 // IF482 serial port parameters\n\n// Settings for DCF77 interface\n//#define HAS_DCF77 GPIO_NUM_1\n//#define DCF77_ACTIVE_LOW 1\n\n// Pins for LORA chip SPI interface, reset line and interrupt lines\n#define LORA_SCK  (5) \n#define LORA_CS   (18)\n#define LORA_MISO (19)\n#define LORA_MOSI (27)\n#define LORA_RST  (14)\n#define LORA_IRQ  (26)\n#define LORA_IO1  (33)\n#define LORA_IO2  LMIC_UNUSED_PIN\n\n#endif\n</code></pre> <p>Output of user sensor data can be switched by user remote control command <code>0x14</code> sent to Port 2.</p> <p>Output of sensor and peripheral data is internally switched by a bitmask register. Default mask can be tailored by editing cfg.payloadmask initialization value in <code>configmanager.cpp</code> following this scheme:</p> Bit Sensordata Default 0 Paxcounter on 1 unused off 2 BME280/680 on 3 GPS* on 4 User sensor 1 on 5 User sensor 2 on 6 User sensor 3 on 7 Batterylevel off <p>*) GPS data can also be combined with paxcounter payload on port 1, <code>#define GPSPORT 1</code> in paxcounter.conf to enable</p> shared/paxcounter_orig.conf<pre><code>#define GPSPORT                         4       // gps - NOTE: set to 1 to send combined GPS+COUNTERPORT payload\n</code></pre>"},{"location":"configuration/#power-saving-mode","title":"Power saving mode","text":"<p>Paxcounter supports a battery friendly power saving mode. In this mode the device enters deep sleep, after all data is polled from all sensors and the dataset is completeley sent through all user configured channels (LORAWAN / SPI / MQTT / SD-Card). Set <code>#define SLEEPCYCLE</code> in paxcounter.conf to enable power saving mode and to specify the duration of a sleep cycle.</p> shared/paxcounter_orig.conf<pre><code>#define SLEEPCYCLE                      0       // sleep time after a send cycle [seconds/10], 0 .. 65535; 0 means no sleep [default = 0]\n</code></pre> <p>Power consumption in deep sleep mode depends on your hardware, i.e. if on board peripherals can be switched off or set to a chip specific sleep mode either by MCU or by power management unit (PMU) as found on TTGO T-BEAM v1.0/V1.1. See <code>power.cpp</code> for power management, and <code>reset.cpp</code> for sleep and wakeup logic.</p>"},{"location":"configuration/#time-sync","title":"Time sync","text":"<p>Paxcounter can keep a time-of-day synced with external or on board time sources. Set <code>#define TIME_SYNC_INTERVAL</code> in <code>paxcounter.conf</code> to enable time sync.</p> shared/paxcounter_orig.conf<pre><code>#define TIME_SYNC_INTERVAL              60      // sync time attempt each .. minutes from time source [default = 60], 0 means off\n</code></pre> <p>Supported external time sources are GPS, LORAWAN network time and LORAWAN application timeserver time. Supported on board time sources are the RTC of ESP32 and a DS3231 RTC chip, both are kept sycned as fallback time sources. Time accuracy depends on board's time base which generates the pulse per second. Supported are GPS PPS, SQW output of RTC, and internal ESP32 hardware timer. Time base is selected by #defines in the board's hal file, see example in <code>generic.h</code>.</p> shared/hal/generic.h<pre><code>// Settings for on board DS3231 RTC chip\n//#define HAS_RTC MY_DISPLAY_SDA, MY_DISPLAY_SCL // SDA, SCL\n//#define RTC_INT GPIO_NUM_34 // timepulse with accuracy +/- 2*e-6 [microseconds] = 0,1728sec / day\n</code></pre> <p>Tip</p> <p>If your LORAWAN network does not support network time, you can run a Node-Red timeserver application using the enclosed Timeserver code. Configure the MQTT nodes in Node-Red for the LORAWAN application used by your paxcounter device. Time can also be set without precision liability, by simple remote command, see section remote control.</p>"},{"location":"configuration/#syncing-multiple-paxcounters","title":"Syncing multiple paxcounters","text":"<p>A fleet of paxcounters can be synchronized to keep all devices wake up and start scanning at the same time. Synchronization is based on top-of-hour as common time point of reference. This feature requires time-of-day to be present on each device. Thus, <code>TIME_SYNC_INTERVAL</code> option, as explained above, must be enabled. Wake up syncing is enabled by setting <code>SYNCWAKEUP</code> in <code>paxcounter.conf</code> to a value X, in seconds, greater than zero, and smaller than <code>SLEEPCYCLE</code> (in seconds/10). This defines a time window, centered at top-of-hour, sized +/- X seconds. If a device, returning from sleep, would wakeup within this time window, it's wakeup will be adjusted to top-of-hour.</p>"},{"location":"configuration/#wall-clock-controller","title":"Wall clock controller","text":"<p>Paxcounter can be used to sync a wall clock which has a DCF77 or IF482 time telegram input. Set <code>#define HAS_IF482</code> or <code>#define HAS_DCF77</code> in board's hal file to setup clock controller. Use case of this function is to integrate paxcounter and clock. Accurary of the synthetic DCF77 signal depends on accuracy of on board's time base, see above.</p>"},{"location":"configuration/#mobile-paxcounter-using-opensensemap","title":"Mobile PaxCounter using openSenseMap","text":"<p>This describes how to set up a mobile PaxCounter: Follow all steps so far for preparing the device, selecting the packed payload format. In <code>paxcounter.conf</code> set <code>PAYLOAD_OPENSENSEBOX</code> to <code>1</code>.</p> shared/paxcounter_orig.conf<pre><code>#define PAYLOAD_OPENSENSEBOX            0       // send payload compatible to sensebox.de (swap geo position and pax data)\n</code></pre> <p>Register a new sensebox on https://opensensemap.org/. In the sensor configuration select \"TheThingsNetwork\" and set decoding profile to \"LoRa serialization\". Enter your TTN Application and Device ID. Setup decoding option using:</p> <pre><code> [{\"decoder\":\"latLng\"},{\"decoder\":\"uint16\",sensor_id\":\"yoursensorid\"}]\n</code></pre>"},{"location":"configuration/#sd-card","title":"SD-card","text":"<p>Data can be stored on a FAT32 (pre-)formatted SD-card if the board provides an SD card interface, either with SPI or MMC mode. To enable this feature, specify interface mode and hardware pins in board's hal file (<code>shared/hal/&lt;board.h\\&gt;</code>):</p> <pre><code>    #define HAS_SDCARD 1     // SD-card interface, using SPI mode\n    //OR\n    #define HAS_SDCARD 2     // SD-card interface, using MMC mode\n\n    // Pins for SPI interface\n    #define SDCARD_CS   (13) // fill in the correct numbers for your board\n    #define SDCARD_MOSI (15)\n    #define SDCARD_MISO (2)\n    #define SDCARD_SCLK (14)\n</code></pre> <p>This is an example of a board with MMC SD-card interface: https://www.aliexpress.com/item/32915894264.html. For this board use file <code>shared/hal/ttgov21new.h</code> and add the lines given above.</p> <p>Another approach would be this tiny board: https://www.aliexpress.com/item/32424558182.html (needs 5V). In this case you choose the correct file for your ESP32-board in the shared/hal-directory and add the lines given above. Edit the pin numbers given in the example, according to your wiring.</p> <p>Data is written on SD-card to a single file. After 3 write operations the data is flushed to the disk to minimize flash write cycles. Thus, up to the last 3 records of data will get lost when the Paxcounter looses power during operation.</p> <p>Format of the resulting file is CSV, thus easy import in LibreOffice, Excel, InfluxDB, etc. Each record contains timestamp (in ISO8601 format), paxcount (wifi and ble) and battery voltage (optional). Voltage is logged if the device has a battery voltage sensor (to be configured in board hal file).</p> <p>File contents example: <pre><code>    timestamp,wifi,ble[,voltage]\n    2022-01-30T21:12:41Z,11,25[,4100]\n    2022-01-30T21:14:24Z,10,21[,4070]\n    2022-01-30T21:16:08Z,12,26[,4102]\n    2022-01-30T21:17:52Z,11,26[,4076]\n</code></pre> If you want to change this, modify <code>src/sdcard.cpp</code> and <code>include/sdcard.h</code>.</p> <p>Additionally, it's possible to redirect system console output to a plain text file on SD card. This can be useful for debugging headless devices in the field. In <code>paxcounter.conf</code> set <code>SDLOGGING</code> to <code>1</code>.</p> shared/paxcounter_orig.conf<pre><code>#define SDLOGGING                       0       // set to 1 for system logging to SD card (if device has one)\n</code></pre>"},{"location":"configuration/custom-sensors/","title":"Custom sensors","text":"<p>You can add up to 3 user defined sensors. Insert your sensor's payload scheme in <code>sensor.cpp</code>. The following exampls show how to add a custom temperature and humidty sensor.</p> <ol> <li>Add variables or needed libraries</li> <li>Add sensor specific code to <code>sensor_init</code> in <code>sensor.cpp</code></li> <li>Add sensor specific code to <code>sensor_read</code> function in <code>sensor.cpp</code></li> <li>Add Payload functions to <code>payload.h</code> and <code>payload.cpp</code> (Optional)</li> <li>Use payload functions in <code>sensor.cpp</code> to send sensor data</li> </ol>"},{"location":"configuration/custom-sensors/#example-1-custom-temperature-and-humidity-sensor-gy-21","title":"Example 1: Custom Temperature and Humidity Sensor GY-21","text":"<p>To use a custom sensor you first have to enable the Sensor which you want to use. For this you have to edit or add <code>HAS_SENSOR_1</code> in either the <code>paxcounter.conf</code> or the <code>hal</code> file of your board.</p> Activate Sensor 1Activate Sensor 2Activate Sensor 3 shared/paxcounter_orig.conf<pre><code>#define HAS_SENSOR_1 1\n</code></pre> shared/paxcounter_orig.conf<pre><code>#define HAS_SENSOR_2 1\n</code></pre> shared/paxcounter_orig.conf<pre><code>#define HAS_SENSOR_3 1\n</code></pre> <p>You might also add a constant for your custom sensor in the <code>paxcounter.conf</code> file. This is optional but can be used to identify the sensor type.</p> shared/paxcounter_orig.conf<pre><code>#define HAS_GY21 1 // (1)\n</code></pre> <ol> <li>See usage of this in the example below</li> </ol>"},{"location":"configuration/custom-sensors/#1-add-variables-or-needed-libraries","title":"1. Add variables or needed libraries","text":"<p>If you want to use any libary for you custom sensor you have to add it to the <code>platformio.ini</code> file.</p> <p>In this example we use the <code>HTU2xD_SHT2x_Si70xx</code> for the GY-21 sensor.</p> platformio.ini<pre><code>[env:usb] # (1)\nupload_protocol = esptool\nlib_deps = # (2)\n    ${common.lib_deps_all}\n    https://github.com/enjoyneering/HTU2xD_SHT2x_Si70xx.git\n</code></pre> <ol> <li>Selected the env you want to use. In this example we use the <code>usb</code> env.</li> <li>Add the libary to the <code>lib_deps</code> section.</li> </ol> <p>Add the import of libary in the <code>sensor.cpp</code> file.</p> sensor.cpp<pre><code>#if (HAS_GY21) // (1)\n#include &lt;HTU2xD_SHT2x_Si70xx.h&gt;\nHTU2xD_SHT2x_SI70xx ht2x(HTU2xD_SENSOR, HUMD_12BIT_TEMP_14BIT); // sensor type, resolution\ndouble temperature, humidity;\n#endif // HAS_GY21\n</code></pre> <ol> <li>Define <code>HAS_GY21</code> either in hal file of your board or in <code>paxcounter.conf</code> file.</li> </ol>"},{"location":"configuration/custom-sensors/#2-add-sensor-specific-code-to-sensor_init-function","title":"2. Add sensor specific code to <code>sensor_init</code> function","text":"src/sensor.cpp<pre><code>#if (HAS_GY21) // (1)\nif (ht2x.begin() != true) // reset sensor, set heater off, set resolution, check power\n                          // (sensor doesn't operate correctly if VDD &lt; +2.25v)\n{\n    ESP_LOGE(TAG, \"HTU2xD/SHT2x not connected, fail or VDD &lt; +2.25v\");\n} else {\n    ESP_LOGE(TAG, \"HTU2xD/SHT2x/GY21 found\");\n}\n#endif // HAS_GY21\n</code></pre> <ol> <li>Define <code>HAS_GY21</code> either in hal file of your board or in <code>paxcounter.conf</code> file.</li> </ol>"},{"location":"configuration/custom-sensors/#3-add-sensor-specific-code-to-sensor_read-function","title":"3. Add sensor specific code to sensor_read function","text":"<p>In this case we choose that our custom sensor is Sensor 3. This means the data will be sent on <code>SENSOR3PORT</code> which is by default <code>12</code>. You can change this in the <code>paxcounter.conf</code> file.</p> src/sensor.cpp<pre><code>  case 3:\n    #if (HAS_GY21)\n    ESP_LOGE(TAG, \"Reading Sensor 3, GY21\"); // (1)\n    temperature =\n        ht2x.readTemperature(); // accuracy +-0.3C in range 0C..60C at  14-bit\n    delay(100);\n    humidity =\n        ht2x.readHumidity(); // accuracy +-2% in range 20%..80%/25C at 12-bit\n    ESP_LOGE(TAG, \"GY21: Temperature: %f\", temperature); // (2)\n    ESP_LOGE(TAG, \"GY21: Humidity: %f\", humidity); // (3)\n    #endif // HAS_GY21\n    break;\n</code></pre> <ol> <li>These logs are only for debugging. You can remove them if you want.</li> <li>These logs are only for debugging. You can remove them if you want.</li> <li>These logs are only for debugging. You can remove them if you want.</li> </ol>"},{"location":"configuration/custom-sensors/#4-payload-functions-for-a-custom-sensor","title":"4. Payload functions for a custom sensor","text":"<p>If you have added your custom sensor code as described before you can also add custom payload function if you need others than the provided ones. For this you have to change two files. First you have to add your payload function to the <code>payload.h</code> file.</p> Example for a custom temperature / humidity payload function src/payload.h<pre><code>void addTempHum(float temperature, float humidity);\n</code></pre> <p>Then you have to add your payload function to the <code>payload.cpp</code> file. You can provide functions for all payload formates (see Payload Formats) or just add it for the one you are using.</p> <p>Example for a custom temperature / humidity payload function</p> Plain payload formatPacked payload formatCayenne payload format src/payload.cpp<pre><code>void PayloadConvert::addTempHum(float temperature, float humidity) {\nint16_t temperature = (int16_t)(temperature); // float -&gt; int\nuint16_t humidity = (uint16_t)(humidity);     // float -&gt; int\nbuffer[cursor++] = highByte(temperature);\nbuffer[cursor++] = lowByte(temperature);\nbuffer[cursor++] = highByte(humidity);\nbuffer[cursor++] = lowByte(humidity);\n}\n</code></pre> src/payload.cpp<pre><code>void PayloadConvert::addTempHum(float temperature, float humidity) {\nwriteFloat(temperature);\nwriteFloat(humidity);\n}\n</code></pre> src/payload.cpp<pre><code>void PayloadConvert::addTempHum(float temperature, float humidity) {\n// data value conversions to meet cayenne data type definition\n// 0.1\u00b0C per bit =&gt; -3276,7 .. +3276,7 \u00b0C\nint16_t temp = temperature * 10;\n// 0.5% per bit =&gt; 0 .. 128 %C\nuint16_t hum = humidity * 2;\n#if (PAYLOAD_ENCODER == 3)\nbuffer[cursor++] = LPP_TEMPERATURE_CHANNEL;\n#endif\nbuffer[cursor++] = LPP_TEMPERATURE; // 2 bytes 0.1 \u00b0C Signed MSB\nbuffer[cursor++] = highByte(temperature);\nbuffer[cursor++] = lowByte(temperature);\n#if (PAYLOAD_ENCODER == 3)\nbuffer[cursor++] = LPP_HUMIDITY_CHANNEL;\n#endif\nbuffer[cursor++] = LPP_HUMIDITY; // 1 byte 0.5 % Unsigned\nbuffer[cursor++] = humidity;\n}\n</code></pre>"},{"location":"configuration/custom-sensors/#5-sending-the-data","title":"5. Sending the data","text":"<p>After you have added your custom sensor code and payload function you can send the data. For this you have to add the following code to the <code>sensor.cpp</code> file.</p> src/sensor.cpp<pre><code>  case 3:\n    #if (HAS_GY21)\n    ESP_LOGE(TAG, \"Reading Sensor 3, GY21\");\n    temperature =\n        ht2x.readTemperature(); // accuracy +-0.3C in range 0C..60C at  14-bit\n    delay(100);\n    humidity =\n        ht2x.readHumidity(); // accuracy +-2% in range 20%..80%/25C at 12-bit\n    ESP_LOGE(TAG, \"GY21: Temperature: %f\", temperature);\n    ESP_LOGE(TAG, \"GY21: Humidity: %f\", humidity);\n    payload.addTempHum(temperature, humidity); // (1)\n    #endif // HAS_GY21\n    break;\n</code></pre> <ol> <li>Add your custom payload function here.</li> </ol> <p>Now you can build and upload the code to your ESP. Do not forget to erase the flash before uploading since you probably changed the <code>paxcounter.conf</code> file.</p>"}]}